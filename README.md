ROS 2 Basics: Course NotesThese notes summarize the key concepts from the "ROS 2 Basics Full Course | 2024" video, with additional details and examples for clarity.1. Introduction to ROS 2What is ROS?ROS stands for Robot Operating System.It's not a traditional OS like Windows or Linux that manages the core hardware. Instead, it's a middleware, meaning it's a software layer that sits on top of an existing OS. Its purpose is to provide a standardized way for different parts of a robot's software to communicate.It provides a collection of tools, libraries, and conventions to simplify the task of creating complex and robust robot behavior. Think of it as a toolbox and a set of rules that let developers build sophisticated robot applications without starting from scratch every time.Why ROS 2?ROS 2 is a complete, ground-up redesign of ROS 1, built to address the limitations of the original and meet the demands of modern robotics.Key Improvements:Multi-robot systems: ROS 2 was designed for robust communication in fleets of robots, making it easier to coordinate tasks between multiple machines.Real-time support: It offers better capabilities for systems where timing is critical, like fast-moving robot arms or drones.Unreliable networks: Communication over Wi-Fi or other lossy networks is more resilient, preventing the system from failing if messages are temporarily dropped.Broader Platform Support: Officially supports Linux, Windows, and macOS, making development more accessible.It uses DDS (Data Distribution Service) as its underlying communication middleware. This is an industry standard for real-time systems that handles how data is discovered, packaged (serialized), and transported between different parts of the system.2. Core ROS 2 ConceptsThe ROS 2 system is based on a graph architecture where different processes (nodes) communicate with each other. Imagine a team of specialists where each person has a job and they communicate through shared channels.Nodes:A node is the fundamental processing unit in ROS. Think of it as a single, independent program or executable that performs a specific task.For modularity, each node should have a single purpose. For example, one node for the camera, one for the wheel motors, one for the laser scanner, and one for path planning. This makes the system easier to debug and reuse.Example: The turtlesim_node is a self-contained program that runs a turtle simulation, handling all the logic and graphics for that specific task.Topics (Pub/Sub Communication):Topics are named buses or channels that act as a conduit for data. Nodes send and receive data over these topics.This is an asynchronous, one-to-many communication model. The publisher doesn't know or care who is listening, and the subscriber doesn't know who is sending. They just agree on the topic name.Publishers: A node that sends (publishes) data to a topic. For instance, a camera node would publish images to an /image_data topic.Subscribers: A node that receives (subscribes to) data from a topic. A separate image processing node could subscribe to /image_data to analyze the images.A single topic can have many publishers and many subscribers, making it a flexible way to distribute data.Messages:Messages are the data structures used for communicating on topics. They define the "language" spoken on a topic.They have a defined type and structure (e.g., integers, floats, strings, or arrays of these). ROS provides many standard message types, but you can also define your own.Example: The geometry_msgs/msg/Twist message type is standard for sending velocity commands. It contains two vectors: linear (for x, y, z motion) and angular (for rotation around x, y, z axes).Services (Request/Response Communication):Services are used for synchronous, one-to-one communication. This is like making a direct phone call to another node and waiting for an answer.This is a request/response model, similar to a remote function call. The client blocks (waits) until the server sends back a response.Service Server: A node that advertises a service and provides a response when called.Service Client: A node that calls the service and waits for the response.Example: A service to /reset a simulation or /spawn a new turtle at a specific location. The client sends the request and waits for a confirmation that the action was completed.Actions:Actions are for long-running, asynchronous tasks that require feedback. They are the ideal choice for goals that can't be completed instantly.They are like services but are non-blocking and provide updates. Instead of waiting for the task to finish, the client can receive continuous feedback.Action Server: Provides the action and reports on its progress.Action Client: Sends a goal to the server (e.g., "navigate to coordinates X, Y").Feedback: The server provides updates (e.g., "distance to goal is 5 meters").Result: The server sends a final result once the goal is complete, cancelled, or has failed.3. ROS 2 Command Line Interface (CLI)The ros2 command is your primary tool for inspecting, debugging, and interacting with a live ROS system.General Syntax: ros2 <verb> <sub-verb> [arguments] (e.g., ros2 topic list)Node Commands:ros2 node list: Lists all currently running nodes. Essential for getting a quick overview of your system.ros2 node info /<node_name>: Your go-to command for debugging a specific node. It shows all its connections: subscriptions, publications, services, and actions.Topic Commands:ros2 topic list: Lists all active topics.ros2 topic list -t: Lists topics and also shows their message types, which is useful for knowing what kind of data is being passed.ros2 topic info /<topic_name>: Shows how many publishers and subscribers are on a topic.ros2 topic echo /<topic_name>: Lets you "spy" on a topic by printing all the data being published on it in real-time. Incredibly useful for debugging.ros2 topic pub --once /<topic_name> <message_type> '<arguments>': Manually publish a single message. Great for testing a node's behavior without needing a full publisher node.Service Commands:ros2 service list: Lists all available services.ros2 service type /<service_name>: Shows the data type of the service, so you know what arguments it expects.ros2 service call /<service_name> <service_type> '<arguments>': Manually call a service from the command line to test its functionality.Action Commands:ros2 action list: Lists all available actions.ros2 action info /<action_name>: Shows details about a specific action.ros2 action send_goal /<action_name> <action_type> '<goal>' --feedback: Sends a goal and also streams the feedback to your terminal, so you can monitor the task's progress.Message/Service/Action Type Commands:ros2 msg show <message_type>: Shows the internal structure of a message (the fields and their data types).ros2 srv show <service_type>: Shows the structure for both the request and the response parts of a service.ros2 action show <action_type>: Shows the structure for the goal, the result, and the feedback parts of an action.4. Workspaces and PackagesWorkspace: A directory that contains your ROS 2 projects. It has a specific structure that colcon (the build tool) understands.src: The "source" directory is where you place the source code of your packages.build: A temporary directory where colcon stores intermediate files during compilation.install: The "destination" directory. After a successful build, the final executables, libraries, and launch files are placed here.log: Contains logs from the build process, useful for diagnosing build failures.Package: The main unit for organizing your code. A package is a folder containing everything needed for a specific functionality (nodes, launch files, message definitions, etc.).package.xml: The manifest file. It contains metadata about the package like its name, version, author, and, most importantly, its dependencies on other ROS 2 packages.setup.py (Python) or CMakeLists.txt (C++): These are build files that tell colcon how to compile and install your code.Building a Workspace:The standard build tool is colcon.Navigate to the root of your workspace and run:colcon build
This command finds all the packages in the src directory, resolves their dependencies, compiles them, and places the results in the install directory.Sourcing the Workspace:After building, your terminal doesn't automatically know about the new executables. You must source the setup file to update your environment.From the workspace root:source install/setup.bash
This adds your install directory to the path, so ROS 2 commands like ros2 run can find your new packages. It's common to add this line to your ~/.bashrc file to source it automatically in every new terminal.5. Creating a ROS 2 Package and Node (Python Example)Navigate to the src directory of your workspace.Create a package:ros2 pkg create --build-type ament_python my_robot_pkg --dependencies rclpy
Create a Node File:Inside my_robot_pkg/my_robot_pkg/, create a Python file, e.g., my_first_node.py.Example Node Code:#!/usr/bin/env python3
import rclpy
from rclpy.node import Node

# All ROS 2 nodes are classes that inherit from rclpy.node.Node
class MyNode(Node):
    def __init__(self):
        # Call the parent class constructor and give the node a name
        super().__init__("my_first_node")
        # Use the node's built-in logger to print a message
        self.get_logger().info("Hello from ROS 2!")

def main(args=None):
    # Initialize the ROS 2 client library
    rclpy.init(args=args)
    # Create an instance of your node
    node = MyNode()
    # "Spin" the node, which keeps it running and allows it to process callbacks
    rclpy.spin(node)
    # Cleanly shut down the ROS 2 client library
    rclpy.shutdown()

if __name__ == "__main__":
    main()
Configure setup.py:Open my_robot_pkg/setup.py and add an entry_points console script. This creates a link so that ros2 run can find and execute the main function in your script.entry_points={
    'console_scripts': [
        "my_node = my_robot_pkg.my_first_node:main"
    ],
},
Build and Run:Go to the workspace root and run colcon build.Source the workspace: source install/setup.bash.Run your node: ros2 run my_robot_pkg my_node.6. Launch FilesLaunch files are scripts that allow you to start and configure multiple nodes with a single command. This is essential for any real robot, which will have many nodes running simultaneously.They are typically written in Python, which gives you the power to add logic like conditionals or loops to your startup process.Example Launch File (my_robot_pkg/launch/my_launch_file.py):from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
    return LaunchDescription([
        Node(
            package='turtlesim',
            executable='turtlesim_node',
            name='my_turtle' # You can rename the node on launch
        ),
        Node(
            package='turtlesim',
            executable='turtle_teleop_key',
            name='my_teleop'
        )
    ])
Running a Launch File:ros2 launch my_robot_pkg my_launch_file.py
